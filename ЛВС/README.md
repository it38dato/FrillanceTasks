<p>Services:<br># Администрирование локальных сетей.<br># Interview.<br><strong>Task:</strong><br>Какая маска подсети Ip 10.20.0.0/23?<br># Interview.<br><strong>Decision:</strong><br>Если 24 - последняя цифра отходит 255.255.255.0. В нашем случае - 255.255.254.0.<br><strong>Task:</strong><br>В вашем распоряжении находится подсеть 192.168.1.0/30. Какие Ip адреса доступны для присвоения устройствам?<br># Interview.<br><strong>Decision:</strong><br>Маска 30 означает, что подряд 30 единиц 11111111.11111111.11111111.11111100. значит ответ 192.168.1.1, 192.168.1.2.<br><strong>Task:</strong><br>Принцип Dos Атаки<br># Interview.<br><strong>Decision:</strong><br>сетевые запросы на сетевом уровне осуществляются с одного компьютера и нацелены на конкретный виртуальный сервер или домен.<br><strong>Task:</strong><br>типы сертификатов<br># Interview.<br><strong>Decision:</strong><br>Пользовательские, Let’s Encrypt<br><strong>Task:</strong><br>Чем Dos Атака отличается от DDos?<br># Interview.<br><strong>Decision:</strong><br>DoS-атаки используют всего один хост для перегрузки системы, есть косвенные признаки, по которым их можно отличить от DDoS. Они менее эффективны и более заметны: когда запросы приходят с одного IP-адреса источника, системному администратору становится очевидна их нелегитимность. Как следствие — DoS-атаки гораздо проще подавить, ведь достаточно использовать брандмауэр.<br><strong>Task:</strong><br>Как создать простое зашифрованное сообщение с помощью командной строки?<br># Interview.<br><strong>Decision:</strong><br>Использовать OpenSsl для шифрования потока текста в текстовый файл, который содержит зашифрованный текст Aes-256 с использованием ключа доступа.<br><strong>Task:</strong><br>типы записей DNS<br># Interview.<br><strong>Decision:</strong><br>A, AAAA, CNAME, MX, PTR, TXT, SRV, NS, SOA.<br><strong>Task:</strong><br>Коды сообщений или ошибок http<br># Interview.<br><strong>Decision:</strong><br>1xx: информационные, 100 продолжайте, 102 идёт обработка.<br>2xx: успешно, 200 хорошо.<br>308 постоянное перенаправление.<br>4xx: ошибка клиента, 400 неправильный, некорректный запрос, 404 не найдено.<br>5xx: ошибка сервера, 500 внутренняя ошибка сервера, 502 плохой, ошибочный шлюз.<br>Translation of the <strong>Decision:</strong><br>1xx: Informational, 100 Continue, 102 Processing.<br>2xx: Success, 200 OK.<br>308 Permanent Redirect.<br>4xx: Client Error, 400 Bad Request, 404 Not Found.<br>5xx: Server Error, 500 Internal Server Error, 502 Bad Gateway.<br><strong>Task:</strong><br>Чем Nginx отличается от Apache?<br># Interview.<br><strong>Decision:</strong><br>асинхронный принцип работы Nginx.<br><strong>Task:</strong><br>Пример Rpo/Rto<br># Interview.<br><strong>Decision:</strong><br>Раз в день в 1:00 делаете бэкап. в 12:00 сгорает сервер. Поставил новый компьютер, установил ОС, программы и восстанавили бэкап. в 17:00 - полное восстановление.<br>Время от последнего бэкапа - Rpo, а время до восстановления - rto. Если организация хочет Rpo 1 час - бэкап надо делать каждый час, а для 1 часа нужно автоматическое создание серверов. Можно сделать реплику потерю данных Rpo на другой сервер.<br><strong>Task:</strong><br>Пример работы DNS<br># Interview.<br><strong>Decision:</strong><br>Ввожу адрес. компьютер понимает только Ip адреса. Поэтому ему надо перевести ваш Url запрос в Ip. Компьютер сначала локально проверят хост файл. в линуксе это reslove. Если в файле прописан жанный адрес, то ответ отправляется пользователю, если нет то проверяется в Dns Серверах на регистрацию адреса. ВОзращается все это по протоколку http.<br><strong>Task:</strong><br>Чем Active Directory отличается от Dns?<br># Interview.<br><strong>Decision:</strong><br>Active Directory использует DNS как механизм поиска контроллеров домена и других объектов.<br><strong>Task:</strong><br>Пример работы инкапсуляции Модель OSI<br># Interview.<br><strong>Decision:</strong><br>Представим ситуацию, что вы сидите у себя дома за компьютером, а в соседней комнате у вас свой локальный веб-сервер. И вот вам понадобилось скачать файл с него. Вы набираете адрес страницы вашего сайта. Сейчас вы используете протокол HTTP, которые работает на прикладном уровне. Данные упаковываются и спускаются на уровень ниже.<br>Полученные данные прибегают на уровень представления. Здесь эти данные структурируются и приводятся в формат, который сможет быть прочитан на сервере. Запаковывается и спускается ниже.<br>На этом уровне создается сессия между компьютером и сервером.<br>Так как это веб сервер и требуется надежное установление соединения и контроль за принятыми данными, используется протокол TCP. Здесь мы указываем порт, на который будем стучаться и порт источника, чтобы сервер знал, куда отправлять ответ. Это нужно для того, чтобы сервер понял, что мы хотим попасть на веб-сервер (стандартно — это 80 порт), а не на почтовый сервер. Упаковываем и спускаем дальше.<br>Здесь мы должны указать, на какой адрес отправлять пакет. Соответственно, указываем адрес назначения (пусть адрес сервера будет 192.168.1.2) и адрес источника (адрес компьютера 192.168.1.1). Заворачиваем и спускаем дальше.<br>IP пакет спускается вниз и тут вступает в работу канальный уровень. Он добавляет физические адреса источника и назначения, о которых подробно будет расписано в последующей статье. Так как у нас компьютер и сервер в локальной среде, то адресом источника будет являться MAC-адрес компьютера, а адресом назначения MAC-адрес сервера (если бы компьютер и сервер находились в разных сетях, то адресация работала по-другому). Если на верхних уровнях каждый раз добавлялся заголовок, то здесь еще добавляется концевик, который указывает на конец кадра и готовность всех собранных данных к отправке.<br>И уже физический уровень конвертирует полученное в биты и при помощи электрических сигналов (если это витая пара), отправляет на сервер.<br><strong>Task:</strong><br>Какой принцип работы Https на примере Chrome?<br># Interview.<br><strong>Decision:</strong><br>Tcp соединение с сервером.<br>Публичный ключ с клиентом.<br>Ключ сессии с сервером.<br>Зашифрованные данные с клиентом.<br><strong>Task:</strong><br>Какой принцип работы Tcp на примере Chrome, Gmail, Ssh ?<br># Interview.<br><strong>Decision:</strong><br>Синхронизация с сервером.<br>Синхронизация ACK с клиентом.<br>ACK с сервером.<br>отправляется пакет и ждет ответ<br><strong>Task:</strong><br>Какой принцип работы Udp на примере Веб конференции?<br># Interview.<br><strong>Decision:</strong><br>Запрос с сервером.<br>Ответ клиенту.<br>Udp не ждет ответа. Udp используется для трансляции.<br><strong>Task:</strong><br>Какой принцип работы Http на примере Chrome?<br># Interview.<br><strong>Decision:</strong><br>Tcp соединение с сервером.<br>Запрос с сервером.<br>Ответ клиенту.<br><strong>Task:</strong><br>Какой принцип работы Ip?<br># Interview.<br><strong>Decision:</strong><br>Компьютерам, серверам и роутерам в интернете нужно понимать, куда отправлять данные.<br>Чтобы узнать IP-адрес вашего устройства, можно открыть терминал и ввести ipconfig в Windows или ifconfig в macOS и Linux.<br>Чаще всего это четыре числа, которые разделены между собой точками (такой формат поддерживается в протоколе IPv4).<br>IP адрес всегда состоит из двух частей: номера хоста (устройства 192.168.1) и номера сети (.23).<br><strong>Task:</strong><br>Пример работы деинкапусуляции Модель OSI<br># Interview.<br><strong>Decision:</strong><br>На физическом уровне принимаются электрические сигналы и конвертируются в понятную битовую последовательность для канального уровня.<br>На канальном уровне проверяется MAC-адрес назначения (ему ли это адресовано). Если да, то проверяется кадр на целостность и отсутствие ошибок, если все прекрасно и данные целы, он передает их вышестоящему уровню.<br>На сетевом уровне проверяется IP адрес назначения. И если он верен, данные поднимаются выше. Не стоит сейчас вдаваться в подробности, почему у нас адресация на канальном и сетевом уровне. Это тема требует особого внимания, и я подробно объясню их различие позже. Главное сейчас понять, как данные упаковываются и распаковываются.<br>На транспортном уровне проверяется порт назначения (не адрес). И по номеру порта, выясняется какому приложению или сервису адресованы данные. У нас это веб-сервер и номер порта — 80.<br>На этом уровне происходит установление сеанса между компьютером и сервером.<br>Уровень представления видит, как все должно быть структурировано и приводит информацию в читабельный вид.<br>И на этом уровне приложения или сервисы понимают, что надо выполнить.<br><strong>Task:</strong><br>Компьютер включен, загружен, подключен к сети, работает корректно, но не «пингуется», в чем может быть причина?<br># Interview.<br><strong>Decision:</strong><br>Брандмауэр (firewall) блокирует ICMP-трафик.<br><strong>Task:</strong><br>Отличие роутера от маршрутизатора<br># Interview.<br><strong>Decision:</strong><br>Маршрутизаторы могут также выполнять функции роутера, но они не обязательно должны быть роутерами. Однако, сегодня многие производители и пользователи используют термины «роутер» и «маршрутизатор» взаимозаменяемо, поскольку устройства, которые выполняют функции обоих, могут называться как роутерами, так и маршрутизаторами.<br><strong>Task:</strong><br>Отличие коммутатора от маршрутизатора<br># Interview.<br><strong>Decision:</strong><br>Отличие в уровне адресации подключенных устройств. Коммутатор работает с физическими (MAC) адресами. Маршрутизатор же может произвести пересылку данных на основании логических (IP) адресов, что позволяет организовать взаимодействие между сетями. Грубо говоря, коммутатор - некое подобие разветвителя, в то время как маршрутизатор - специальное сетевое устройство, пересылающее пакеты данных.<br><strong>Task:</strong><br>Отличие запросов Get и Post<br># Interview.<br><strong>Decision:</strong><br>Запрос Get передает данные в Url через ссылку, Post передает данные в теле запроса.<br><strong>Task:</strong><br>The simplest network<br>Для организации простейшей сети потребуется Два компьютера и Патч-корд. В случае отсутствия патч-корда<br>необходимы: Кусок витой пары, Два коннектора RJ45.<br># Администрирование локальных сетей.<br><strong>Decision:</strong><br>end devices - PC0 - PC1 - connections - copper cross-cover - PC0 - Desktop - ip configuration - ipv4 - 192.168.1.1 - subnet mask - 255.255.255.0 - PC1 - Desktop - ip configuration - ipv4 - 192.168.1.2 - subnet mask - 255.255.255.0 - PC0 - Desktop - Command Prompt<br>C:\&gt;ping 192.168.1.2<br>&nbsp;&nbsp;Pinging 192.168.1.2 with 32 bytes of data:<br>&nbsp;&nbsp;Reply from 192.168.1.2: bytes=32 time&lt;1ms TTL=128<br>&nbsp;&nbsp;Reply from 192.168.1.2: bytes=32 time&lt;1ms TTL=128<br>&nbsp;&nbsp;Reply from 192.168.1.2: bytes=32 time&lt;1ms TTL=128<br>&nbsp;&nbsp;Reply from 192.168.1.2: bytes=32 time&lt;1ms TTL=128<br>&nbsp;&nbsp;Ping statistics for 192.168.1.2:<br>&nbsp;&nbsp;&nbsp;&nbsp;Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),<br>&nbsp;&nbsp;Approximate round trip times in milli-seconds:<br>&nbsp;&nbsp;&nbsp;&nbsp;Minimum = 0ms, Maximum = 0ms, Average = 0ms<br><strong>Task:</strong><br>We have a router, a switch, 2 computers and a server that acts as a tftp server.<br>Проверим какая версия прошивки у коммутатора<br># Администрирование локальных сетей.<br><strong>Decision:</strong><br>&nbsp;&nbsp;switch0-CLI<br>Switch&gt;en<br>Switch#show ver<br>&nbsp;&nbsp;Cisco IOS Software, C2960 Software (C2960-LANBASE-M), Version 12.2(25)FX, RELEASE SOFTWARE (fc1)<br>&nbsp;&nbsp;Copyright (c) 1986-2005 by Cisco Systems, Inc.<br>&nbsp;&nbsp;Compiled Wed 12-Oct-05 22:05 by pt_team<br>&nbsp;&nbsp;ROM: C2960 Boot Loader (C2960-HBOOT-M) Version 12.2(25r)FX, RELEASE SOFTWARE (fc4)<br>&nbsp;&nbsp;System returned to ROM by power-on<br>&nbsp;&nbsp;Cisco WS-C2960-24TT (RC32300) processor (revision C0) with 21039K bytes of memory.<br>&nbsp;&nbsp;24 FastEthernet/IEEE 802.3 interface(s)<br>&nbsp;&nbsp;2 Gigabit Ethernet/IEEE 802.3 interface(s)<br>&nbsp;&nbsp;63488K bytes of flash-simulated non-volatile configuration memory.<br>&nbsp;&nbsp;Base ethernet MAC Address&nbsp;&nbsp;   : 0090.2B80.9BA3<br>&nbsp;&nbsp;Motherboard assembly number&nbsp;&nbsp; : 73-9832-06<br>&nbsp;&nbsp;Power supply part number&nbsp;&nbsp;&nbsp;&nbsp;: 341-0097-02<br>&nbsp;&nbsp;Motherboard serial number&nbsp;&nbsp;   : FOC103248MJ<br>&nbsp;&nbsp;Power supply serial number&nbsp;&nbsp;  : DCA102133JA<br>&nbsp;&nbsp;Model revision number&nbsp;&nbsp;&nbsp;&nbsp;   : B0<br>&nbsp;&nbsp;Motherboard revision number&nbsp;&nbsp; : C0<br>&nbsp;&nbsp;Model number&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: WS-C2960-24TT<br>&nbsp;&nbsp;System serial number&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: FOC1033Z1EY<br>Switch#reload<br>&nbsp;&nbsp;Proceed with reload? [confirm]<br>&nbsp;&nbsp;C2960 Boot Loader (C2960-HBOOT-M) Version 12.2(25r)FX, RELEASE SOFTWARE (fc4)<br>&nbsp;&nbsp;Cisco WS-C2960-24TT (RC32300) processor (revision C0) with 21039K bytes of memory.<br>&nbsp;&nbsp;2960-24TT starting...<br>&nbsp;&nbsp;Base ethernet MAC Address: 0090.2B80.9BA3<br>&nbsp;&nbsp;Xmodem file system is available.<br>&nbsp;&nbsp;Initializing Flash...<br>&nbsp;&nbsp;flashfs[0]: 1 files, 0 directories<br>&nbsp;&nbsp;flashfs[0]: 0 orphaned files, 0 orphaned directories<br>&nbsp;&nbsp;flashfs[0]: Total bytes: 64016384<br>&nbsp;&nbsp;flashfs[0]: Bytes used: 4414921<br>&nbsp;&nbsp;flashfs[0]: Bytes available: 59601463<br>&nbsp;&nbsp;flashfs[0]: flashfs fsck took 1 seconds.<br>&nbsp;&nbsp;...done Initializing Flash.<br>&nbsp;&nbsp;Boot Sector Filesystem (bs:) installed, fsid: 3<br>&nbsp;&nbsp;Parameter Block Filesystem (pb:) installed, fsid: 4<br>&nbsp;&nbsp;Loading "flash:/c2960-lanbase-mz.122-25.FX.bin"...<br>&nbsp;&nbsp;...<br>Switch#show flash:<br>&nbsp;&nbsp;Directory of flash:/<br>&nbsp;&nbsp;&nbsp;&nbsp;1  -rw-&nbsp;&nbsp; 4414921&nbsp;&nbsp;&nbsp;&nbsp;  &lt;no date&gt;  c2960-lanbase-mz.122-25.FX.bin<br>&nbsp;&nbsp;64016384 bytes total (59601463 bytes free)<br><strong>Task:</strong><br>Обновим прошивку<br># Администрирование локальных сетей.<br><strong>Decision:</strong><br>&nbsp;&nbsp;Server-Services-tftp<br>&nbsp;&nbsp;c2960-lanbasek9-mz.150-2.SE4.bin<br>Switch&gt;en<br>Switch#conf t<br>&nbsp;&nbsp;Enter configuration commands, one per line.  End with CNTL/Z.<br>Switch(config)#int vlan 1<br>Switch(config-if)#ip add<br>Switch(config-if)#ip address 192.168.1.5 255.255.255.0<br>Switch(config-if)#no shut<br>Switch(config-if)#no shutdown<br>Switch(config-if)#<br>&nbsp;&nbsp;%LINK-5-CHANGED: Interface Vlan1, changed state to up<br>&nbsp;&nbsp;%LINEPROTO-5-UPDOWN: Line protocol on Interface Vlan1, changed state to up<br>Switch(config-if)#exit<br>Switch(config)#exit<br>Switch#<br>&nbsp;&nbsp;%SYS-5-CONFIG_I: Configured from console by console<br>Switch#ping 192.168.1.4<br>&nbsp;&nbsp;Type escape sequence to abort.<br>&nbsp;&nbsp;Sending 5, 100-byte ICMP Echos to 192.168.1.4, timeout is 2 seconds:<br>&nbsp;&nbsp;.!!!!<br>&nbsp;&nbsp;Success rate is 80 percent (4/5), round-trip min/avg/max = 0/0/0 ms<br>Switch#copy ?<br>&nbsp;&nbsp;  flash:&nbsp;&nbsp;&nbsp;&nbsp;  Copy from flash: file system<br>&nbsp;&nbsp;  ftp:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copy from ftp: file system<br>&nbsp;&nbsp;  running-config  Copy from current system configuration<br>&nbsp;&nbsp;  scp:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copy from scp: file system<br>&nbsp;&nbsp;  startup-config  Copy from startup configuration<br>&nbsp;&nbsp;  tftp:&nbsp;&nbsp;&nbsp;&nbsp;   Copy from tftp: file system<br>Switch#copy tf<br>Switch#copy tftp: ?<br>&nbsp;&nbsp;  flash:&nbsp;&nbsp;&nbsp;&nbsp;  Copy to flash: file system<br>&nbsp;&nbsp;  running-config  Copy configuration from system<br>&nbsp;&nbsp;  startup-config  Copy startup configuration from system<br>Switch#copy tftp: fl<br>Switch#copy tftp: flash:<br>&nbsp;&nbsp;Address or name of remote host []? 192